ft_memset:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_bzero:      [OK] [OK] [OK] [OK] 
ft_memcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memmove:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] [OK] [OK] [OK] [OK] [OK] [OK] 
[crash]: your memmove does not work with a 128Mo data input !
Test code:
	int size = 128 * 1024 * 1024;
	char *dst = (char *)malloc(sizeof(char) * size);
	char *data = (char *)malloc(sizeof(char) * size);

	memset(data, 'A', size);
	if (!dst)
		exit(TEST_INVISIBLE);
	ft_memmove(dst, data, size);
	exit(TEST_SUCCESS);


ft_memchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memcmp:     [OK] [OK] [OK] [OK] [OK] [FAILED] [FAILED] [OK] [OK] [OK] 
[fail]: your memcmp stop at \0
Test code:
	char *s1 = "atoms\0\0\0\0";
	char *s2 = "atoms\0abc";
	size_t size = 8;
	int i1 = ((simple_memcmp(s1, s2, size) > 0) ? 1 : ((simple_memcmp(s1, s2, size) < 0) ? -1 : 0));
	int i2 = ((ft_memcmp(s1, s2, size) > 0) ? 1 : ((ft_memcmp(s1, s2, size) < 0) ? -1 : 0));

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      memcmp: |-1|
   ft_memcmp: |0|

[fail]: your memcmp does not work with basic input
Test code:
	char *s1 = "\xff\0\0\xaa\0\xde\xffMACOSX\xff";
	char *s2 = "\xff\0\0\xaa\0\xde\x00MBS";
	size_t size = 9;
	int i1 = ((simple_memcmp(s1, s2, size) > 0) ? 1 : ((simple_memcmp(s1, s2, size) < 0) ? -1 : 0));
	int i2 = ((ft_memcmp(s1, s2, size) > 0) ? 1 : ((ft_memcmp(s1, s2, size) < 0) ? -1 : 0));

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      memcmp: |1|
   ft_memcmp: |0|

ft_strlen:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_isalpha:    [OK] 
ft_isdigit:    [OK] 
ft_isalnum:    [OK] 
ft_isascii:    [OK] 
ft_isprint:    [OK] 
ft_toupper:    [OK] 
ft_tolower:    [OK] 
ft_strchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strrchr:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strncmp:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlcpy:    [OK] [OK] [FAILED] [OK] [FAILED] [OK] [OK] 
[fail]: your strlcpy overflow the dest
Test code:
	char *str = "BBBB";
	char buff1[0xF00];
	char buff2[0xF00];

	memset(buff1, 'A', 20);
	memset(buff2, 'A', 20);
	strlcpy(buff1, str, sizeof(buff1));
	ft_strlcpy(buff2, str, sizeof(buff2));
	if (!memcmp(buff1, buff2, 20))
		exit(TEST_SUCCESS);
	for (register int __i = 0; __i < 20; ++__i)
	for (register int __i = 0; __i < 20; ++__i)
	exit(TEST_FAILED);

Diffs:
     strlcpy: |\x0  \x42 \x42 \x42 \x0  \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 |
  ft_strlcpy: |\x42 \x42 \x42 \x42 \x0  \x41 \x0  \x41 \x0  \x41 \x0  \x41 \x0  \x41 \x0  \x41 \x0  \x41 \x0  \x41 |

[fail]: your strlcpy does not works with 0-length string
Test code:
	char *str = "";
	char buff1[0xF00];
	char buff2[0xF00];
	size_t r1;
	size_t r2;

	memset(buff1, 'A', 20);
	memset(buff2, 'A', 20);
	r1 = strlcpy(buff1, str, sizeof(buff1));
	r2 = ft_strlcpy(buff2, str, sizeof(buff2));
	if (r1 == r2 && !memcmp(buff1, buff2, 20))
		exit(TEST_SUCCESS);
	if (r1 != r2)
	{
	}
		for (register int __i = 0; __i < 20; ++__i)
		for (register int __i = 0; __i < 20; ++__i)
	}
	exit(TEST_FAILED);

Diffs:
     strlcpy: |\x0  \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 \x41 |
  ft_strlcpy: |\x0  \x41 \x0  \x41 \x0  \x41 \x0  \x41 \x0  \x41 \x0  \x41 \x0  \x41 \x0  \x41 \x0  \x41 \x0  \x41 |

ft_strlcat:    [FAILED] [FAILED] [FAILED] [OK] [FAILED] [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [CRASH] 
[fail]: your strlcat does not work with basic input
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = strlen("the cake is a lie !\0I'm hidden lol\r\n") + 4;

	strlcat(buff1, str, max);
	ft_strlcat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcat: |there is no stars in the sky|
  ft_strlcat: |there is no stars in th|

[fail]: your strlcat does not work with basic input
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = strlen("the cake is a lie !\0I'm hidden lol\r\n") + 4;
	size_t r1 = strlcat(buff1, str, max);
	size_t r2 = ft_strlcat(buff2, str, max);

	if (r1 != r2)
		exit(TEST_FAILED);
	char s1[4] = "";
	char s2[4] = "";
	r1 = strlcat(s1, "thx to ntoniolo for this test !", 4)
		;
	r2 = ft_strlcat(s2, "thx to ntoniolo for this test !", 4)
		;
	if (r1 != r2)
		exit(TEST_FAILED);
	exit(TEST_SUCCESS);

Diffs:
     strlcat: |42|
  ft_strlcat: |23|

[fail]: your strlcat does not work with basic input
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = strlen("the cake is a lie !\0I'm hidden lol\r\n") + strlen("there is no stars in the sky");

	strlcat(buff1, str, max);
	ft_strlcat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcat: |there is no stars in the skythe cake is a lie |
  ft_strlcat: |there is no stars in the skythe cake is a lie !|

[fail]: your strlcat does not work with a size of 0
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = 0;

	strlcat(buff1, str, max);
	ft_strlcat(buff2, str, max);
	if (!strcmp(buff1, buff2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcat: |there is no stars in the sky|
  ft_strlcat: ||

[fail]: your strlcat return value is false
Test code:
	char *src = "aaa";
	char dst1[20];
	char dst2[20];
	int ret1;
	int ret2;

	memset(dst1, 'B', sizeof(dst1));
	memset(dst2, 'B', sizeof(dst2));
	strlcat(dst1, src, 20);
	strlcat(dst1, src, 20);
	ret1 = strlcat(dst1, src, 20);
	ft_strlcat(dst2, src, 20);
	ft_strlcat(dst2, src, 20);
	ret2 = ft_strlcat(dst2, src, 20);
	if (ret1 == ret2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcat: |23|
  ft_strlcat: |20|

[crash]: your strlcat crush when null parameter is sent with a size of 0
Test code:
	char b[0xF] = "nyan !";

	ft_strlcat(((void*)0), b, 0);
	exit(TEST_SUCCESS);


ft_strnstr:    [OK] [OK] [OK] [FAILED] [OK] [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
[fail]: your strnstr does not work with basic input
Test code:
	char *big = "abcdef";
	char *little = "abcdefghijklmnop";
	size_t max = strlen(big);
	char *s1 = strnstr(big, little, max);
	char *s2 = ft_strnstr(big, little, max);

	if (s1 == s2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strnstr: |(null)|
  ft_strnstr: |abcdefghijklmnop|

[fail]: your strnstr does not work with not found patern
Test code:
	char *s1 = "FF";
	char *s2 = "see FF your FF return FF now FF";
	char *i1 = strnstr(s1, s2, 4);
	char *i2 = ft_strnstr(s1, s2, 4);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strnstr: |(null)|
  ft_strnstr: |see FF your FF return FF now FF"; char *s2 = "FF"; size_t max = strlen(s1); char *i1 = strnstr(s1, s2, max); char *i2 = ft_strnstr(s1, s2, max); if (i1 == i2) exit(TEST_SUCCESS); lseek(g_diff_fd, 0, 0); dprintf(g_diff_fd, "%12s: |%.300s|\n%12s: |%.300s|", current_fun_name + 3, (char*)i1, current_fun|

ft_atoi:       [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_calloc:     [OK] [CRASH] [OK] [OK] [OK] 
[crash]: you didn't protect your malloc return
Test code:
	char *ptr;

	ptr = ft_calloc(4, 20);
	if (!ptr)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_strdup:     [CRASH] [OK] [OK] [OK] [OK] [OK] [OK] 
[crash]: you didn't protect your malloc return
Test code:
	char *ptr;

	ptr = ft_strdup("lol");
	if (!ptr)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_substr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] {not protected}[FAILED] 
[fail]: your substr does not work when start >= ft_strlen(s)
Test code:
	char *str = "01234";
	size_t size = 10;
	char *ret = ft_substr(str, 10, size);

	if (!strncmp(ret, "", 1))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
      substr: ||
   ft_substr: |{not protected}tr = ft_s|

ft_strjoin:    [OK] [OK] [OK] [OK] [OK] {not protected}
ft_strtrim:    [OK] [FAILED] [FAILED] [FAILED] [FAILED] [KO] [OK] [CRASH] [OK] {not protected}
[fail]: your strtrim does not work with basic input
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !";
	char *s2 = "Hello \t  Please\n Trim me !";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |Hello 	  Please
 Trim me !t_strnstr: |abcdefghijklmnop||

[fail]: your strtrim does not work with basic input
Test code:
	char *s1 = "Hello \t  Please\n Trim me !";
	char *s2 = "Hello \t  Please\n Trim me !";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: |Hello 	  Please
 Trim me !|
  ft_strtrim: |Hello 	  Please
 Trim me !rlcat: |20||

[fail]: your strtrim does not work with full blank input
Test code:
	char *s1 = "  \t \t \n   \n\n\n\t";
	char *s2 = "";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: ||
  ft_strtrim: | 0, 0); dprintf(g_diff_f|

[fail]: your strtrim does not work with empty input
Test code:
	char *s1 = "";
	char *s2 = "";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: ||
  ft_strtrim: |[FAILED] printf(g_diff_f|

[KO]: your strtrim did not allocate the good size so the \0 test may be false
Test code:
	char *s1 = "\t   \n\n\n  \n\n\t    Hello \t  Please\n Trim me !\t\t\t\n  \t\t\t\t  ";
	char *s2 = "Hello \t  Please\n Trim me !";
	int r_size = strlen(s2);
	int size;

	ft_strtrim(s1, " \n\t");
	size = get_last_malloc_size();
	if (size == r_size + 1)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
     strtrim: |27|
  ft_strtrim: |55|

[crash]: you dont protect your malloc return
Test code:
	char *s1 = "   \t  \n\n \t\t  \n\n\nHello \t  Please\n Trim me !\n   \n \n \t\t\n  ";

	char *ret = ft_strtrim(s1, " \n\t");
	if (ret == ((void*)0))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_split:      [FAILED] [OK] [FAILED] [OK] [OK] [OK] [FAILED] [FAILED] [CRASH] [FAILED] {not protected}
[fail]: your split does not work with basic input
Test code:
	char *string = "      split       this for   me  !       ";
	char **expected = ((char*[6]){"split", "this", "for", "me", "!", ((void*)0)});
	char **result = ft_split(string, ' ');

	split_cmp_array(expected, result);

Diffs:
       split: |split|
    ft_split: | |

[fail]: your split does not work with one word
Test code:
	char *s = "                  olol";
	char **result = ft_split(s, ' ');

	split_cmp_array(expected, result);

Diffs:
       split: |olol|
    ft_split: | |

[fail]: your split will segfault in case --> *str="\0aa\0bbb" c='\0' 
Test code:
	char **expected = ft_split("\0aa\0bbb", '\0');

	for (int i = 0; expected[i]; i++)
	{
		if (expected[i] != ((void*)0))
			exit(TEST_FAILED);
	}
	exit(TEST_SUCCESS);

Diffs:


[fail]: your split does not work with basic input
Test code:
	char *s = "split  ||this|for|me|||||!|";
	int i = 0;
	char **result = ft_split(s, '|');

	while (result[i])
	{
		if (strcmp(result[i], *expected))
		{
			exit(TEST_FAILED);
		}
		free(result[i]);
		i++;
		expected++;
	}
	free(result);
	exit(TEST_SUCCESS);

Diffs:
       split: |this|
    ft_split: ||this|

[crash]: you did not protect your split
Test code:
	char *s = "      split       this for   me  !       ";

	char **result = ft_split(s, ' ');
	if (!result)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[fail]: your split does not work with basic input
Test code:
	char *s = "      split       this for   me  !       ";

	char **result = ft_split(s, ' ');
	while (*result)
	{
		if (strcmp(*result, *expected))
		{
			exit(TEST_FAILED);
		}
		result++;
		expected++;
	}
	exit(TEST_SUCCESS);

Diffs:
       split: |split|
    ft_split: | |

ft_itoa:       [MISSING]
ft_strmapi:    [MISSING]
ft_putchar_fd: [MISSING]
ft_putstr_fd:  [MISSING]
ft_putendl_fd: [MISSING]
ft_putnbr_fd:  [MISSING]
ft_lstnew:     [MISSING]
ft_lstadd_front: [MISSING]
ft_lstsize:    [MISSING]
ft_lstlast:    [MISSING]
ft_lstadd_back:[MISSING]
ft_lstdelone:  [MISSING]
ft_lstclear:   [MISSING]
ft_lstiter:    [MISSING]
ft_lstmap:     [MISSING]
